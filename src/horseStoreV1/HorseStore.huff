// send calldata -> function dispatch -> function

// macros -> function (different) 
// contract creation bytecode: 60008060093d393df3
// after pushing 0 to stack: 60018060093d393df35f

// each compiled contract has 3 sections:
//    * contract creation
//    * runtime
//    * metadata
// compiler adds INVALID opcode between sections

// CODCOPY (39) -> contract creation -> deploying contract 

// EVM is a stack machine -> temporary data 
// Memory -> stick any variable (anywhere) and it stays there until the end of the transaction
// Storage -> persistant - data stays there (even after transaction) -> more expensive 

// PUSHX -> X is the number of bytes pushed to the stack


#define macro MAIN() = takes(0) returns(0) {
    /*
    0x00 // PUSH0 -> TOP [0] BOTTOM
    calldataload     // [calldata] -> puts the first 32 bytes of calldata on stack
    0xe0             // [0xe0, calldata]
    shr              // [function selector]
    */
    0x00 calldataload 0xE0 shr // function selector

    // if f_selector == updateHorseNumber -> jump there
    dup1 // duplicate top of the stack
    // cast sig "updateHorseNumber(uint256)" -> 0xcdfead2e
    0xcdfead2e
    eq // true if function selector matches
    // jump to function 
    // cast sig "readNumberOfHorses()" -> 0xe026c017
    updateJump    // [updateHorseNumberPC, true/false]
    jumpi

    0xe026c017
    eq
    readJump
    jumpi

    updateJump:
        SET_NUMBER_OF_HORSES()
    readJump:
        GET_NUMBER_OF_HORSES()
}

#define macro SET_NUMBER_OF_HORSES() = takes(0) returns(0) {}

#define macro GET_NUMBER_OF_HORSES() = takes(0) returns(0) {}